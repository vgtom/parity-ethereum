//! Utility functions.
//!
//! Contains small functions used by the AuRa engine that are not strictly limited to that scope.

use std::fmt;

use ethabi;
use ethereum_types::{Address, U256};
use parking_lot::RwLock;

use block::ExecutedBlock;
use client::{BlockId, EngineClient};
use engines::signer::EngineSigner;
use executive::{Executive, TransactOptions};
use machine::EthereumMachine;
use transaction::{self, Action, SignedTransaction, Transaction};

/// A contract bound to a client and block number.
///
/// A bound contract is a combination of a `Client` reference, a `BlockId` and a contract `Address`.
/// These three parts are enough to call a contract's function; return values are automatically
/// decoded.
pub struct BoundContract<'a> {
	client: &'a EngineClient,
	machine: &'a EthereumMachine,
	signer: &'a RwLock<EngineSigner>,
	block: &'a mut ExecutedBlock,
	contract_addr: Address,
}

/// Contract call failed error.
#[derive(Debug)]
pub enum CallError {
	/// The call itself failed.
	CallFailed(String),
	/// Decoding the return value failed or the decoded value was a failure.
	DecodeFailed(ethabi::Error),
	/// The passed in client reference could not be upgraded to a `BlockchainClient`.
	NotFullClient,
	/// The transaction required to make a call could not be scheduled.
	TransactionFailed(transaction::Error),
}

impl<'a> fmt::Debug for BoundContract<'a> {
	fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
		fmt.debug_struct("BoundContract")
			.field("client", &(self.client as *const EngineClient))
			.field("contract_addr", &self.contract_addr)
			.finish() // TODO
	}
}

impl<'a> BoundContract<'a> {
	/// Create a new `BoundContract`.
	#[inline]
	pub fn bind(client: &'a EngineClient,
				machine: &'a EthereumMachine,
				signer: &'a RwLock<EngineSigner>,
				block: &'a mut ExecutedBlock,
				contract_addr: Address)
		-> BoundContract<'a>
	{
		BoundContract {
			client,
			machine,
			signer,
			block,
			contract_addr,
		}
	}

	/// Perform a function call to an ethereum machine that doesn't create a transaction or change the state.
	///
	/// Runs a constant function call on `client`. The `call` value can be serialized by calling any
	/// api function generated by the `use_contract!` macro. This does not create any transactions, it only produces a
	/// result based on the state at the current block.
	pub fn call_const<D>(&self, call: (ethabi::Bytes, D)) -> Result<D::Output, CallError>
	where
		D: ethabi::FunctionOutputDecoder,
	{
		let (data, output_decoder) = call;
		let cl = self.client.as_full_client().ok_or(CallError::NotFullClient)?;

		// Clone the block's state: We don't actually mutate the block itself.
		let mut state = self.block.state.clone();

		// Create a transaction. This will not be pushed onto the block and just executed virtually.
		let transaction = self.new_transaction(data).fake_sign(Address::default());
		let env_info = self.block.env_info();

		let options = TransactOptions::with_no_tracing().dont_check_nonce();
		let schedule = self.machine.schedule(self.block.header.number());
		let executed = Executive::new(&mut state, &env_info, &self.machine, &schedule)
			.transact_virtual(&transaction, options).unwrap();

		// Decode the result and return it.
		output_decoder.decode(executed.output.as_slice()).map_err(CallError::DecodeFailed)
	}

	/// Executes and pushes a service transaction (with gas price zero) that calls a contract to the block.
	///
	/// The `call` value can be serialized by calling any API function generated by the `use_contract!` macro.
	pub fn push_service_transaction<D>(&mut self, call: (ethabi::Bytes, D)) -> Result<(), CallError> {
		// NOTE: The second item of `call` is actually meaningless, since the function will only be
		//       executed later on when the transaction is processed. For this reason, there is no
		//       `ethabi::FunctionOutputDecoder` trait bound on it, even though the `use_contract`
		//       macro generates these for constant and non-constant functions the same way.
		let (data, _) = call;

		let transaction = self.new_transaction(data);
		let chain_id = Some(self.machine.params().chain_id); // TODO: See EIP155?
		let signature = self.signer.read().sign(transaction.hash(chain_id))
			.map_err(|e| transaction::Error::InvalidSignature(e.to_string())).unwrap(); // TODO
		let signed_tx = SignedTransaction::new(transaction.with_signature(signature, chain_id)).unwrap(); // TODO

		self.block.push_transaction(&self.machine, signed_tx, None).unwrap(); // TODO
		Ok(())
	}

	/// Creates a new transaction with the given contract call data.
	fn new_transaction(&self, data: ethabi::Bytes) -> Transaction {
		Transaction {
			nonce: self.block.state.nonce(self.block.header.author()).unwrap(), // TODO
			action: Action::Call(self.contract_addr),
			gas: U256::from(1000000),
			gas_price: U256::zero(),
			value: U256::zero(),
			data,
		}
	}
}
